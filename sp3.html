<!DOCTYPE html>
<html>
<head>
<!--
<meta http-equiv="refresh" content="2" />
-->
<style>

body {
margin: auto 10%;
}
section {
  page-break-inside: avoid;
  border: 0 solid #eee;
}
/*
section section + section {
  border-color: #ddd;
  border-width: 0 0 0 0;
}
body > section {
  border-color: #777;
  border-width: medium 0 0 0;
}
*/
p {
  text-align: justify;
}
h3 {
}
body script {
  display: block;
  white-space: pre;
  font-family: monospace;
  margin: 1em 0;
}
#tests {
  display: none;
}

tdÂ {
  vertical-align: top;
}
pre {
  margin: 1em 2em;
}
textarea:hover {
  cursor: default;
}
textarea#input:hover {
  background-color: #f6f6ff;
}
textarea.invalid {
  background-color: #fee;
}
textarea#input.invalid {
  background-color: #fee;
}
table td {
  border: thin solid #aaa;
  background-color: #eee;
  font-family: sans-serif;
  padding: 0.2em;
  vertical-align: right;
}
table.tapestry th {
  border: thin solid #aaa;
  font-family: sans-serif;
  background-color: #eee;
}
table.tapestry td.nullcell {
  background-color: transparent;
  border-width: 0;
}
table.tapestry th.group {
  background-color: transparent;
  border-width: 0;
}
.rotate {
  -webkit-transform: rotate(-90deg);
  -moz-transform: rotate(-90deg);
}
.match {
  color: #a00;
  font-weight: bold;
}
</style>
</head>
<body>
<p>
582615: Overlay and P2P Networks, Spring 2013
</p>

<section>
<h1>Spoiler Package III</h1>

<p>This spoiler package contains some answers for <a href="ex3.html">Exercise Package III</a>.

<section>
<h2>Assignment 9, Spoiler</h2>

<section>
<h3>a.</h3>
<p>
The CAN topology is presented as a wrapping section of x-dimensional (xD) space,
where x depends on the configuration of the CAN instance. Depending on the amount
of dimensions the topology is either a ring (1D), a torus (2D) or a hypertorus
(xD, x&gt;2). In colloquial language tori are often referred to as doughnuts
because of their resemblance to a type of bakery product. Each CAN node is responsible for a
zone in the CAN topology. Neighbours in the topology maintain connections to each other.
The shape of a zone also depends on the amount of dimensions. A zone can be a line
segment (1D), a rectangle (2D), a cuboid (3D) or a hypercuboid (xD, x&gt;3).
</p>
<p>
When a new node joins the CAN network a random coordinate is selected as the point
where the new node gets inserted. The system uses basic routing
to find the node that is responsible for the selected coordinate. The node responsible
for that point divides its zone into two halves, and the new node becomes responsible
for the objects in one of the halves, while the original node remains responsible
for the other half. As a zone is split the two nodes transfer the corresponding
objects to the new node and update the routing tables of the neighbouring nodes
to match the change. Finally, as the two halves of the original zone are next to
each other, both of the two nodes add the other to their routing table.
</p>
</section>
<section>
<h3>b.</h3>
<p>
As depicted by Figure 4 in the CAN article, adding dimensions increases routing
efficiency. However, as more dimensions are added, the benefit of adding more
dimensions decreases. Adding dimensions also increases routing table sizes.
Thus there exists a limit how far performance can be improved by adding
dimensions.
</p>
</section>
<section>
<h3>c.</h3>
<p>
The amount of realities refers to redundant copies of the CAN topology in a
single CAN deployment. Each node may end up responsible for different
objects in different realities. Thus, the amount of realities affects the
amount of redundant copies available on the system.
</p>
<p>
The routing performance increase gained from adding
realities is pretty similar to that of adding dimensions, as can be seen
by comparing Figure 4 with Figure 5. However, the cost of adding realities
is higher because of the increased replication.
</p>
</section>
</section>

<section>
<h2>Assignment 10, Spoiler</h2>

<section>
<h3>a.</h3>
<p>
K-bucket size affects the theoretical maximum  amount of connections in
the network. With k-bucket size zero there can be no connections.
With huge k-bucket sizes the network has the potential of becoming
fully connected. Thus, increasing the size of k-buckets increases
routing performance, but also increases the routing table size.
Increased routing tables require more memory, and require the host
to maintain a larger amount of connections.
</p>
<p>
Try experimenting with different parameters in the Kademlia Visualizer at
<a href="http://www.cs.helsinki.fi/u/twruottu/kademlia/kademlia.html">http://www.cs.helsinki.fi/u/twruottu/kademlia/kademlia.html</a>
</p>
</section>

<section>
<h3>b.</h3>
<p>
Lets consider this question for 5 bit identifiers and hope it generalizes to n bits. With 5 bit identifiers the maximum amount of nodes is 2^5 = 32. With bucket size 0 the routing table does not have space for any nodes.
</p>
<p>
The nodes are divided to different buckets in a way, where half of the nodes are placed in one of the buckets, half of the remaining nodes are placed in the following bucket and so forth until we run out of nodes. The nodes do not store their own identifier in any bucket. Thus, with the bucket size of 32 / 2 &gt;= 16, all existing nodes fit into the routing table.
</p>
<p>
The amount of nodes added with each bucket size increase are as follows.
<table>
<tr>
<th>increased to</th>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>...</td>
<tr>
<th>required additional space</th>
<td>5</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>...</td>
</table>
</p>
<p>
If we integrate this with a pocket calculator we get the following.
<table>
<tr>
<th>bucket size</th>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>...</td>
<tr>
<th>required space</th>
<td>0</td>
<td>5</td>
<td>9</td>
<td>12</td>
<td>15</td>
<td>17</td>
<td>19</td>
<td>21</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>31</td>
<td>31</td>
<td>31</td>
<td> ...</td>
</table>
</p>
<p>
Now, by using a plotter we get the following chart.
</p>
<object data="http://chart.apis.google.com/chart?cht=lc&amp;chtt=Space Requirement&amp;chs=600x375&amp;chxt=x,y&amp;chxl=0:|0|19|1:|0|40&amp;chds=0,40&amp;chd=t:0,5,9,12,15,17,19,21,23,24,25,26,27,28,29,30,31,31,31,31" type="image/png"></object>
<p>
We look at the plot and believe that the storage requirement increases logarithmically. If we would wish someone else to believe us as well, we would continue with a formal proof that verifies our belief. The proof should probably take into account identifier lengths other than 5 bits.
</p>
<p>
In the analysis above, we estimated the maximum space requirement for the routing table. In practice the nodes are not necessarily aware of all the other nodes that could potentially exist in their routing table. In fact it is not very likely for all the nodes even exist. Even more so because long identifier lengths are often used to make collisions less likely.
</p>
<p>
The Kademlia paper also describes optimizations where memory for the routing
table gets allocated dynamically. The bookkeeping required for the
optimization causes some processing overhead, but saves space when the
routing table is not full.
</p>

</section>

<section>
<h3>c.</h3>
<p>
<em>
Part c was pretty much an open question. To get points one would need to
either analyse what the authors claim in the paper, or compare Kademlia
to some other DHT, or analyse an
existing DHT comparison table with Kademlia in it. Perhaps the
comparison table from the lecture slides, or perhaps one from some
scientific article that compares different DHTs.
</em>
</p>
</section>

</section>

<section>
<h2>Assignment 11, 12, Spoilers</h2>
<p style="border: medium solid #a00; padding: 1em;">I will update the spoiler package as I proceed creating the example answers.
<br />Cheers, --Toni</p>
</section>
<!--
<section>
<h2>Assignment 6, Spoiler</h2>

<section>
<h3>a.</h3>
<p>

</p>
<p>
   [1] <a href=""></a> <br />
</p>
</section>
</section>
-->
</section>

</body>
</html>
