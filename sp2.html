<!DOCTYPE html>
<html>
<head>
<!--
<meta http-equiv="refresh" content="2" />
-->
<style>
body {
margin: auto 10%;
}
section {
  page-break-inside: avoid;
  border: 0 solid #eee;
}
/*
section section + section {
  border-color: #ddd;
  border-width: 0 0 0 0;
}
body > section {
  border-color: #777;
  border-width: medium 0 0 0;
}
*/
p {
  text-align: justify;
}
h3 {
}
body script {
  display: block;
  white-space: pre;
  font-family: monospace;
  margin: 1em 0;
}
#tests {
  display: none;
}

tdÂ {
  vertical-align: top;
}
pre {
  margin: 1em 2em;
}
textarea:hover {
  cursor: default;
}
textarea#input:hover {
  background-color: #f6f6ff;
}
textarea.invalid {
  background-color: #fee;
}
textarea#input.invalid {
  background-color: #fee;
}
table.tapestry td {
  border: thin solid #aaa;
  background-color: #eee;
  font-family: sans-serif;
  font-size: 0.7em;
}
table.tapestry th {
  border: thin solid #aaa;
  font-family: sans-serif;
  background-color: #eee;
}
table.tapestry td.nullcell {
  background-color: transparent;
  border-width: 0;
}
table.tapestry th.group {
  background-color: transparent;
  border-width: 0;
}
.rotate {
  -webkit-transform: rotate(-90deg);
  -moz-transform: rotate(-90deg);
}
.match {
  color: #a00;
  font-weight: bold;
}
</style>
<script>
  "use strict";
  function init() {
    pretty('input');
    pretty('output');
    var input = document.getElementById('input');
    var output = document.getElementById('output');
    input.addEventListener('keyup', user_update_output, true);
    output.addEventListener('keyup', user_update_input, true);

    tests();
    update_output();
  }

  function compare(json_answer1, json_answer2) {
    var answer1 = JSON.parse(json_answer1);
    var answer2 = JSON.parse(json_answer2);
    var nodes1 = Object.keys(answer1);
    var nodes2 = Object.keys(answer2);
    if(nodes1.length != nodes2.length) {
      return 'different amount of nodes';
    }
    nodes1.sort();
    nodes2.sort();
    for (var i in nodes1) {
      var node1 = nodes1[i];
      var node2 = nodes1[i];
      if (node1 != node2) {
        return 'different set of nodes';
      }
    }
    for (var key in answer1) {
      var objects2 = answer2[key];
      if (typeof(objects2) == typeof(undefined)) {
        return 'answer2 is missing a key ' + key;
      }
      var objects1 = answer1[key];
      if (objects1.length != objects2.length) {
        return 'object amounts differ for key ' + key;
      }
      objects2.sort();
      objects1.sort();
      for (var i in objects1) {
        var object1 = objects1[i];
        var object2 = objects2[i];
        if (object1 != object2) {
          return 'objects differ for key ' + key;
        }
      }
    }
  }

  function test(i) {
    var input_element = document.getElementById('input-' + i);
    var output_element = document.getElementById('output-' + i);
    var json_input = input_element.innerHTML;
    var json_example = output_element.innerHTML;
    var json_output = transform(json_input);
    var error = compare(json_output, json_example);
    if (typeof(error) != typeof(undefined)) {
      console.log('problem detected while executing test-' + i);
      console.log(error);
    }
  }

  function validate_input() {
    var input_element = document.getElementById('input');
    var json_input = input_element.value;
    try {
      var input = JSON.parse(json_input);
    } catch(e) {
      input_element.setAttribute('class', 'invalid')
      return;
    }
    input_element.removeAttribute('class')
  }

  function validate_output() {
    var output_element = document.getElementById('output');
    var json_output = output_element.value;
    try {
      var output = JSON.parse(json_output);
    } catch(e) {
      output_element.setAttribute('class', 'invalid')
      return;
    }
    output_element.removeAttribute('class')
  }

  function validate_fields() {
    validate_input();
    validate_output();
  }

  function user_update_input() {
    try {
      update_input();
    } catch (e) {
    }
  }

  function user_update_output() {
    try {
      update_output();
    } catch (e) {
    }
  }

  function update_input() {
    validate_fields();
    var input_element = document.getElementById('input');
    var output_element = document.getElementById('output');
    var json_output = output_element.value;
    var json_input = detransform(json_output);
    var input = JSON.parse(json_input);
    var pretty = JSON.stringify(input, null, '  ');
    input_element.value = pretty;
    validate_fields();
  }

  function update_output() {
    validate_fields();
    var input_element = document.getElementById('input');
    var output_element = document.getElementById('output');
    var json_input = input_element.value;
    var json_output = transform(json_input);
    var output = JSON.parse(json_output);
    var pretty = JSON.stringify(output, null, '  ');
    output_element.value = pretty;
    validate_fields();
  }

  function tests() {
    test(1);
  }

  function pretty(field) {
    var element = document.getElementById(field);
    var json = element.value;
    var content = JSON.parse(json);
    var pretty = JSON.stringify(content, null, '  ');
    element.value = pretty;
  }

  function detransform(json_output) {
    var output = JSON.parse(json_output);
    var nodes = [];
    var objects = [];
    for (var node in output) {
      nodes.push(node);
      var store = output[node];
      for (var i in store) {
        var obj = store[i];
        objects.push(obj);
      }
    }
    nodes.sort();
    objects.sort();
    var input = {}
    input['nodes'] = nodes;
    input['objects'] = objects;
    var json_input = JSON.stringify(input);
    return json_input;
  }

  window.addEventListener('load', init, false);
</script>
</head>
<body>
<p>
582615: Overlay and P2P Networks, Spring 2013
</p>

<section>
<h1>Spoiler Package II</h1>

<p>
Many course participants were unfamiliar with the rules for doing quotations.
Therefore, no minus points were given for failure in quotation or failure in pointing out sources.
However, please check the list of <a href="problems.html">common quotation problems</a>
to avoid loosing points on other courses. Double check the rules before attempting to do
scientific publications, such as a master's thesis.
</p>
<p>
Direct quotes were ignored while grading the assignments.
Thus, a low score for an assignment does not necessarily imply that the answer was incorrect.
Furthermore, it was possible to get full points regardless of some errors.
Therefore, a high score does not imply that everything in the answer was correct.
</p>

<section>
<h2>Assignment 5, Spoiler</h2>

<p>
In Chord the identifier space forms a ring that is used
to decide which node is responsible for which object.
The identifier space wraps so after the biggest identifier
it returns to the smallest.
Each object that matches a node identifier will be stored
on the matching node. If the object identifier does not
match a node the object will be stored on the next node
in the ring.
</p>
<p>
Thus, a node would typically store objects that have
an identifier which is smaller or equal to the node
identifier. The wrapping point is an exception where
the node with the smallest identifier may end up
storing some objects with large identifiers. Also,
some nodes might end up storing no objects.</p>

<p>
Below you'll find an example how a simplified json input
would transform. It is interactive. Try modifying the input.
</p>
<table>
<tr>
<th>input</th>
<th>output</th>
</tr>
<tr><td>
<textarea id="input" rows="20">
{
  "nodes": ["00036", "34783", "76321", "93125"],
  "objects": ["00737", "01105", "01564", "76475",
              "76493", "76494", "76512", "93125",
              "93127"]
}
</textarea>
</td><td>
<textarea id="output" rows="20" readonly="readonly">
{
  "00036": ["93127"],
  "34783": ["00737", "01105", "01564"],
  "76321": [],
  "93125": ["76475", "76493", "76494", "76512", "93125"]
}
</textarea>
</td></tr></table>
<p>
Note that json is agnostic to the order of keys in the object,
and the assignment definition did not specify the order for
object identifiers in the list.
<!--
 The keys and identifiers are
ordered here by their size for convenience of the reader.
-->
You might write the transformation in javascript as follows.
</p>
<script>
function transform(json_input) {
  var input = JSON.parse(json_input);
  var nodes = input['nodes'];
  var objects = input['objects'];
  nodes.sort();
  objects.sort();
  var output = {};
  var obj = objects.shift();
  var node = nodes.shift();
  var first_node = node;
  while (typeof(node) != typeof(undefined)) {
    var store = [];
    while (obj <= node) {
      store.push(obj);
      obj = objects.shift();
    }
    output[node] = store;
    node = nodes.shift();
  }
  if (typeof(first_node) != typeof(undefined)) {
    var first_store = output[first_node];
    while (typeof(obj) != typeof(undefined)) {
      first_store.push(obj);
      obj = objects.shift();
    }
  }
  var json_output = JSON.stringify(output);
  return json_output;
}
</script>

<p>
While the assignment description had example code written in Python
I ended up using javascript here so I was able to hook it up
to the example above.
</p>

</section>

<section>
<h2>Assignment 6, Spoiler</h2>

<section>
<h3>a.</h3>
<p>

<p>Lets consider node 8D84 with the neighbours 3D67, 5610, 6065, 8072, 8120, 8121, 82B9, 83F3, 8412, 891F, 8CF9, 8D01, 8D21, 8D59, 8D70, 8D82, 8D83, 8D88, 8D8A, 8D8C, 8D8D, 8D8F, 8D99, 8DCE, 8DFD, 8F2A, 9AD1, B380, DBCA and E782.
</p>


<table class="tapestry">
<tr>
<td colspan="2" rowspan="2" class="nullcell"></td>
<th colspan="16" class="group">symbol</th>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
</tr>
<tr>
<th rowspan="5" class="group rotate">level</th>
</tr>
<tr>
<th>1</th>
<td></td>
<td></td>
<td></td>
<td><span class="match">3</span>D67</td>
<td></td>
<td><span class="match">5</span>610</td>
<td><span class="match">6</span>065</td>
<td></td>
<td class="nullcell"></td>
<td><span class="match">9</span>AD1</td>
<td ></td>
<td><span class="match">B</span>380</td>
<td ></td>
<td><span class="match">D</span>BCA</td>
<td><span class="match">E</span>782</td>
<td></td>
</tr>
<tr>
<th>2</th>
<td>8<span class="match">0</span>72</td>
<td>8<span class="match">1</span>20</td>
<td>8<span class="match">2</span>B9</td>
<td>8<span class="match">3</span>F3</td>
<td>8<span class="match">4</span>12</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>8<span class="match">9</span>1F</td>
<td></td>
<td></td>
<td>8<span class="match">C</span>F9</td>
<td class="nullcell"></td>
<td></td>
<td>8<span class="match">F</span>2A</td>

</tr>
<tr>
<th>3</th>

<td>8D<span class="match">0</span>1</td>
<td></td>
<td>8D<span class="match">2</span>1</td>
<td></td>
<td></td>
<td>8D<span class="match">5</span>9</td>
<td></td>
<td>8D<span class="match">7</span>0</td>
<td class="nullcell"></td>
<td>8D<span class="match">9</span>9</td>
<td></td>
<td></td>
<td>8D<span class="match">C</span>E</td>
<td></td>
<td></td>
<td>8D<span class="match">F</span>D</td>


</tr>
<tr>
<th>4</th>
<td></td>
<td></td>
<td>8D8<span class="match">2</span></td>
<td>8D8<span class="match">3</span></td>
<td class="nullcell"></td>
<td></td>
<td></td>
<td></td>
<td>8D8<span class="match">8</span></td>
<td></td>
<td>8D8<span class="match">A</span></td>
<td></td>
<td>8D8<span class="match">C</span></td>
<td>8D8<span class="match">D</span></td>
<td></td>
<td>8D8<span class="match">F</span></td>

</tr>
</table>

<p>
As 8120 and 8121 would go into the same slot in the routing table Tapestry discards one or the other based on proximity of the two nodes in the underlay. The white cells in the routing table are never accessed, since they match the local node identifier.
</p>

</p>
</section>
<section>
<h3>b.</h3>
<p>
Queries contain an identifier for the object that is to be stored or retrieved.
The object identifiers and node identifiers have the same format.
Each node that receives the query does routing decisions based on its local
routing table.
</p>
<p>
To determine a cell in the routing table the local node needs to examine
the object identifier present in the query.
The correct column in the routing table is determined by the first symbol that
differs from the local node identifier.
The correct row is determined based on the longest common prefix between
the object identifier and the local node identifier. No common prefix selects row 1, a common prefix of length one selects row 2, and so forth.
</p>
<p>
After selecting a cell in the routing table the node forwards the query
to the neighbour identified by the cell.
When the selected cell is empty, the node picks another node
deterministically using a separate algorithm.
</p>
</section>
<section>
<h3>c.</h3>
<p>

</p>
</section>
</section>

<section>
<h2>Assignment 7, 8, Spoilers</h2>
<p style="border: medium solid #a00; padding: 1em;">I will update the spoiler package as I proceed creating the example answers.
Expect some more before Sunday morning.
<br />Cheers, --Toni</p>
</section>
<!--
<section>
<h2>Assignment 6, Spoiler</h2>

<section>
<h3>a.</h3>
<p>

</p>
<p>
   [1] <a href=""></a> <br />
</p>
</section>
</section>
-->
</section>

<div id="tests">
<pre id="input-1">
{
  "nodes": ["00036", "34783", "76321", "93125"],
  "objects": ["00737", "01105", "01564", "76475",
              "76493", "76494", "76512", "93125",
              "93127"]
}
</pre>
<pre id="output-1">
{
  "00036": ["93127"],
  "34783": ["00737", "01105", "01564"],
  "76321": [],
  "93125": ["76475", "76493", "76494", "76512", "93125"]
}
</pre>
</div>
</body>
</html>
